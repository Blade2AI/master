#include "VerifyEvidenceLib.h"
#include <fstream>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <algorithm>
#include <cctype>
#include <vector>
#include <string>
#include <set>
#include <unordered_map>

#ifdef SODIUM_AVAILABLE
#include <sodium.h>
#endif

static bool g_hash_diag_printed = false; // ensure single diagnostic print

static void hash_diag(const char* impl) {
    if (!g_hash_diag_printed) {
        std::cerr << "[HASH_IMPL] " << impl << "\n";
        g_hash_diag_printed = true;
    }
}

static std::string to_hex(const std::vector<unsigned char>& data) {
    std::ostringstream ss;
    ss << std::hex << std::setfill('0');
    for (unsigned char c : data) ss << std::setw(2) << (int)c;
    return ss.str();
}

// --- Portable SHA256 implementation (public domain, simplified) ---
#ifndef SODIUM_AVAILABLE
#include <cstring>
#include <stdint.h>
namespace portable_sha256 {
    typedef uint8_t  u8;
    typedef uint32_t u32;
    typedef uint64_t u64;
    struct SHA256_CTX {
        u32 state[8], datalen;
        u64 bitlen;
        u8 data[64];
    };
    static const u32 k[64] = {
        0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
        0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
        0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
        0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
        0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
        0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
        0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
        0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
    };
    #define ROTRIGHT(a,b) (((a) >> (b)) | ((a) << (32-(b))))
    #define CH(x,y,z) (((x) & (y)) ^ (~(x) & (z)))
    #define MAJ(x,y,z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
    #define EP0(x) (ROTRIGHT(x,2) ^ ROTRIGHT(x,13) ^ ROTRIGHT(x,22))
    #define EP1(x) (ROTRIGHT(x,6) ^ ROTRIGHT(x,11) ^ ROTRIGHT(x,25))
    #define SIG0(x) (ROTRIGHT(x,7) ^ ROTRIGHT(x,18) ^ ((x) >> 3))
    #define SIG1(x) (ROTRIGHT(x,17) ^ ROTRIGHT(x,19) ^ ((x) >> 10))
    static void sha256_transform(SHA256_CTX *ctx, const u8 data[]){
        u32 a,b,c,d,e,f,g,h,i,j,t1,t2,m[64];
        for(i=0,j=0;i<16;++i,j+=4)
            m[i]=(data[j]<<24)|(data[j+1]<<16)|(data[j+2]<<8)|(data[j+3]);
        for(;i<64;++i)
            m[i]=SIG1(m[i-2])+m[i-7]+SIG0(m[i-15])+m[i-16];
        a=ctx->state[0];b=ctx->state[1];c=ctx->state[2];d=ctx->state[3];
        e=ctx->state[4];f=ctx->state[5];g=ctx->state[6];h=ctx->state[7];
        for(i=0;i<64;++i){
            t1=h+EP1(e)+CH(e,f,g)+k[i]+m[i];
            t2=EP0(a)+MAJ(a,b,c);
            h=g;g=f;f=e;e=d+t1;d=c;c=b;b=a;a=t1+t2;
        }
        ctx->state[0]+=a;ctx->state[1]+=b;ctx->state[2]+=c;ctx->state[3]+=d;
        ctx->state[4]+=e;ctx->state[5]+=f;ctx->state[6]+=g;ctx->state[7]+=h;
    }
    static void sha256_init(SHA256_CTX *ctx){
        ctx->datalen=0;ctx->bitlen=0;
        ctx->state[0]=0x6a09e667;ctx->state[1]=0xbb67ae85;ctx->state[2]=0x3c6ef372;ctx->state[3]=0xa54ff53a;
        ctx->state[4]=0x510e527f;ctx->state[5]=0x9b05688c;ctx->state[6]=0x1f83d9ab;ctx->state[7]=0x5be0cd19;
    }
    static void sha256_update(SHA256_CTX *ctx, const u8 data[], size_t len){
        for(size_t i=0;i<len;++i){
            ctx->data[ctx->datalen]=data[i];ctx->datalen++;
            if(ctx->datalen==64){sha256_transform(ctx,ctx->data);ctx->bitlen+=512;ctx->datalen=0;}
        }
    }
    static void sha256_final(SHA256_CTX *ctx, u8 hash[]){
        u32 i=ctx->datalen;
        if(ctx->datalen<56){ctx->data[i++]=0x80;while(i<56)ctx->data[i++]=0x00;}
        else{ctx->data[i++]=0x80;while(i<64)ctx->data[i++]=0x00;sha256_transform(ctx,ctx->data);memset(ctx->data,0,56);}
        ctx->bitlen+=ctx->datalen*8;ctx->data[63]=ctx->bitlen;ctx->data[62]=ctx->bitlen>>8;ctx->data[61]=ctx->bitlen>>16;ctx->data[60]=ctx->bitlen>>24;
        ctx->data[59]=ctx->bitlen>>32;ctx->data[58]=ctx->bitlen>>40;ctx->data[57]=ctx->bitlen>>48;ctx->data[56]=ctx->bitlen>>56;sha256_transform(ctx,ctx->data);
        for(i=0;i<4;++i)for(u32 j=0;j<8;++j)hash[i+j*4]=(ctx->state[j]>>(24-i))&0xff;
    }
    static std::vector<unsigned char> sha256(const std::string &data) {
        SHA256_CTX ctx; unsigned char hash[32];
        sha256_init(&ctx);
        sha256_update(&ctx, reinterpret_cast<const u8*>(data.data()), data.size());
        sha256_final(&ctx, hash);
        return std::vector<unsigned char>(hash, hash+32);
    }
}
#endif

#ifdef SODIUM_AVAILABLE
std::vector<unsigned char> compute_sha256(const std::string &data) {
    hash_diag("libsodium_sha256");
    std::vector<unsigned char> out(32);
    crypto_hash_sha256(out.data(), reinterpret_cast<const unsigned char*>(data.data()), data.size());
    return out;
}
#else
std::vector<unsigned char> compute_sha256(const std::string &data) {
    hash_diag("portable_sha256");
    return portable_sha256::sha256(data);
}
#endif

bool verify_signature_ed25519(const std::vector<unsigned char>& pubkey,
                              const std::vector<unsigned char>& sig,
                              const std::string& message) {
#ifdef SODIUM_AVAILABLE
    if (sig.size() != crypto_sign_BYTES || pubkey.size() != crypto_sign_PUBLICKEYBYTES) return false;
    int rc = crypto_sign_verify_detached(sig.data(), reinterpret_cast<const unsigned char*>(message.data()), message.size(), pubkey.data());
    return rc == 0;
#else
    (void)pubkey; (void)sig; (void)message; return false;
#endif
}

static bool is_hex_string(const std::string &s) {
    if (s.empty() || (s.size() % 2) != 0) return false;
    for (char c : s) if (!std::isxdigit(static_cast<unsigned char>(c))) return false;
    return true;
}

std::vector<unsigned char> load_pubkey_from_file(const std::string &path, std::string &err) {
    std::vector<unsigned char> result;
    std::ifstream in(path, std::ios::binary);
    if (!in) {
        err = "Failed to open pubkey file: " + path;
        return result;
    }
    std::ostringstream ss;
    ss << in.rdbuf();
    std::string content = ss.str();

    auto l = content.find_first_not_of(" \n\r\t");
    auto r = content.find_last_not_of(" \n\r\t");
    if (l == std::string::npos) content = ""; else content = content.substr(l, r - l + 1);

    if (is_hex_string(content)) {
        result.reserve(content.size()/2);
        for (size_t i = 0; i < content.size(); i += 2) {
            std::string byte = content.substr(i, 2);
            unsigned char val = static_cast<unsigned char>(std::stoul(byte, nullptr, 16));
            result.push_back(val);
        }
    } else {
        result.assign(content.begin(), content.end());
    }
    return result;
}

std::string compute_merkle_root_from_files(const std::vector<std::string>& paths) {
    std::vector<std::vector<unsigned char>> hashes;
    for (const auto &p : paths) {
        std::ifstream in(p, std::ios::binary);
        if (!in) {
            // Use empty content hash
            hashes.push_back(compute_sha256(std::string()));
            continue;
        }
        std::ostringstream ss;
        ss << in.rdbuf();
        auto h = compute_sha256(ss.str());
        hashes.push_back(h);
    }

    if (hashes.empty()) {
        auto h = compute_sha256(std::string());
        return to_hex(h);
    }

    while (hashes.size() > 1) {
        std::vector<std::vector<unsigned char>> next;
        for (size_t i = 0; i < hashes.size(); i += 2) {
            std::vector<unsigned char> left = hashes[i];
            std::vector<unsigned char> right = (i + 1 < hashes.size()) ? hashes[i+1] : hashes[i];
            std::string concat;
            concat.reserve(left.size() + right.size());
            concat.append(reinterpret_cast<const char*>(left.data()), left.size());
            concat.append(reinterpret_cast<const char*>(right.data()), right.size());
            next.push_back(compute_sha256(concat));
        }
        hashes.swap(next);
    }
    return to_hex(hashes[0]);
}

// -------- Batch Merkle Proof Implementation --------
// Helper: compute leaf hashes from file paths
static std::vector<std::vector<unsigned char>> compute_leaf_hashes(const std::vector<std::string>& paths) {
    std::vector<std::vector<unsigned char>> hashes;
    hashes.reserve(paths.size());
    for (const auto &p : paths) {
        std::ifstream in(p, std::ios::binary);
        if (!in) { hashes.push_back(compute_sha256(std::string())); continue; }
        std::ostringstream ss; ss << in.rdbuf(); hashes.push_back(compute_sha256(ss.str()));
    }
    return hashes;
}

BatchMerkleProof build_batch_merkle_proof(const std::vector<std::string>& paths,
                                          const std::vector<size_t>& targetIndices) {
    BatchMerkleProof proof; if (paths.empty() || targetIndices.empty()) return proof;
    // Unique & sorted target indices
    std::set<size_t> targets(targetIndices.begin(), targetIndices.end());
    std::vector<size_t> sortedTargets(targets.begin(), targets.end());

    auto leaves = compute_leaf_hashes(paths);
    size_t n = leaves.size();
    // Build full tree levels (bottom-up storage of hashes)
    std::vector<std::vector<std::vector<unsigned char>>> levels; // levels[0] = leaves
    levels.push_back(leaves);
    while (levels.back().size() > 1) {
        const auto &cur = levels.back();
        std::vector<std::vector<unsigned char>> next;
        for (size_t i = 0; i < cur.size(); i += 2) {
            const auto &left = cur[i];
            const auto &right = (i+1 < cur.size()) ? cur[i+1] : cur[i];
            std::string concat; concat.reserve(left.size()+right.size());
            concat.append(reinterpret_cast<const char*>(left.data()), left.size());
            concat.append(reinterpret_cast<const char*>(right.data()), right.size());
            next.push_back(compute_sha256(concat));
        }
        levels.push_back(next);
    }
    proof.rootHex = to_hex(levels.back()[0]);

    // Mark target positions per level
    std::vector<std::set<size_t>> marked; // marked[l] indices in level l that are needed
    marked.resize(levels.size());
    for (size_t idx : sortedTargets) if (idx < n) marked[0].insert(idx);

    // Propagate markings upward and collect auxiliary siblings
    std::set<std::string> auxDedup; // avoid duplicate hex entries
    for (size_t lvl = 0; lvl < levels.size()-1; ++lvl) {
        const auto &cur = levels[lvl];
        for (size_t index : marked[lvl]) {
            size_t sibling = (index % 2 == 0) ? index + 1 : index - 1;
            if (sibling >= cur.size()) sibling = index; // mirrored
            // Include sibling if sibling not also marked (i.e. not a target at this level)
            if (marked[lvl].find(sibling) == marked[lvl].end()) {
                std::string sibHex = to_hex(cur[sibling]);
                if (auxDedup.insert(sibHex).second) proof.auxSiblingsHex.push_back(sibHex);
            }
            // Mark parent in next level
            size_t parent = index / 2;
            marked[lvl+1].insert(parent);
        }
    }

    // Leaf hashes for targets
    for (size_t idx : sortedTargets) {
        if (idx < n) proof.leafHashesHex.push_back(to_hex(leaves[idx]));
        proof.leafIndices.push_back(idx);
    }

    return proof;
}

bool verify_batch_merkle_proof(const BatchMerkleProof& proof) {
    if (proof.leafIndices.empty() || proof.rootHex.empty()) return false;
    // Reconstruct upward: we need to simulate combining leaves & aux siblings.
    // For simplicity in this minimal implementation we recompute all parent hashes from provided leaves + assume aux sibling set is sufficient.
    // A stricter implementation would track structure steps; here we just validate that each leaf can reach root using available aux hashes greedily.
    std::set<std::string> aux(proof.auxSiblingsHex.begin(), proof.auxSiblingsHex.end());
    for (size_t i = 0; i < proof.leafIndices.size(); ++i) {
        std::string curHex = proof.leafHashesHex[i];
        size_t idx = proof.leafIndices[i];
        size_t levelSpan = 0; // attempt to climb levels by dividing index by 2 each time
        size_t workingIndex = idx;
        std::string current = curHex;
        while (true) {
            if (current == proof.rootHex) break; // reached root
            // sibling position
            size_t siblingIndex = (workingIndex % 2 == 0) ? workingIndex + 1 : workingIndex - 1;
            // Compute sibling hash hex (need to locate in aux set or if mirrored use current)
            std::string siblingHex;
            if (aux.find(siblingHex) != aux.end()) {
                // case placeholder - we would consume. This simplistic approach can't reliably map level structure without steps.
            }
            // Without structural steps we cannot safely validate intermediate parents; break to avoid false positive.
            // A full verification requires proof steps; return false to enforce completeness.
            return false;
        }
    }
    return true; // unreachable with current logic; reserved for future expansion.
}
