#include "../VerifyEvidenceLib.h"
#include "../../../deps/catch2/catch.hpp"
#include "ed25519_test_vectors.h"
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <iostream>
#include <filesystem>
#include <random>

namespace fs = std::filesystem;

static std::string abs_path(const std::string &rel) {
    return fs::absolute(fs::path(rel)).string();
}

TEST_CASE(Merkle_RightOrder_ComputesExpectedRoot) {
    std::vector<std::string> paths = {
        abs_path("../..//test_data/evidence1.txt"),
        abs_path("../..//test_data/evidence2.txt"),
        abs_path("../..//test_data/evidence3.txt")
    };
    std::string root = compute_merkle_root_from_files(paths);
    std::string expected = compute_merkle_root_from_files(paths);
    REQUIRE(root == expected);
}

TEST_CASE(Merkle_TamperedFile_FailsMatch) {
    std::vector<std::string> paths = {
        abs_path("../..//test_data/evidence1.txt"),
        abs_path("../..//test_data/evidence2.txt"),
        abs_path("../..//test_data/evidence3.txt")
    };
    std::string original_root = compute_merkle_root_from_files(paths);

    std::string tamper_path = abs_path("../..//test_data/evidence2.txt");
    std::ifstream in(tamper_path, std::ios::binary);
    std::ostringstream ss; ss << in.rdbuf(); std::string original = ss.str(); in.close();

    // Strong tamper: overwrite with random marker
    std::string tampered = "TAMPER_MARKER_";
    std::mt19937 rng{12345};
    for (int i=0;i<16;++i) tampered.push_back(static_cast<char>('A' + (rng() % 26)));
    {
        std::ofstream out(tamper_path, std::ios::binary | std::ios::trunc);
        out.write(tampered.data(), tampered.size());
    }

    std::string tampered_root = compute_merkle_root_from_files(paths);

    // Restore original
    {
        std::ofstream restore(tamper_path, std::ios::binary | std::ios::trunc);
        restore.write(original.data(), original.size());
    }

    REQUIRE(original_root != tampered_root);
}

#ifdef SODIUM_AVAILABLE
TEST_CASE(Signature_Verify_Success) {
    REQUIRE(verify_signature_ed25519(TEST_PUBKEY, TEST_SIG, TEST_MESSAGE));
}

TEST_CASE(Signature_Verify_InvalidSignature_Fails) {
    std::vector<unsigned char> bad_sig = TEST_SIG;
    bad_sig[0] ^= 0xFF; // flip a bit
    REQUIRE(!verify_signature_ed25519(TEST_PUBKEY, bad_sig, TEST_MESSAGE));
}

TEST_CASE(Signature_Verify_WrongPubkey_Fails) {
    REQUIRE(!verify_signature_ed25519(WRONG_PUBKEY, TEST_SIG, TEST_MESSAGE));
}
#endif

int main(int argc, char** argv) { return run_all_tests(); }
