#include "../VerifyEvidenceLib.h"
#include "../../../deps/catch2/catch.hpp"
#include "ed25519_test_vectors.h"
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <iostream>
#include <random>

static std::string read_file(const std::string &p) {
    std::ifstream in(p, std::ios::binary);
    std::ostringstream ss; ss << in.rdbuf();
    return ss.str();
}

TEST_CASE(Merkle_RightOrder_ComputesExpectedRoot) {
    std::vector<std::string> paths = {
        "../../test_data/evidence1.txt",
        "../../test_data/evidence2.txt",
        "../../test_data/evidence3.txt"
    };
    std::string root = compute_merkle_root_from_files(paths);
    std::string expected = compute_merkle_root_from_files(paths);
    REQUIRE(root == expected);
}

TEST_CASE(Merkle_TamperedFile_FailsMatch) {
    std::vector<std::string> paths = {
        "../../test_data/evidence1.txt",
        "../../test_data/evidence2.txt",
        "../../test_data/evidence3.txt"
    };
    std::string original_root = compute_merkle_root_from_files(paths);

    std::string tamper_path = "../../test_data/evidence2.txt";
    std::string original = read_file(tamper_path);

    // Strong tamper: overwrite entirely with random marker
    std::string tampered = "TAMPER_MARKER_";
    std::mt19937 rng{98765};
    for (int i=0;i<32;++i) tampered.push_back(static_cast<char>('A' + (rng() % 26)));
    {
        std::ofstream out(tamper_path, std::ios::binary | std::ios::trunc);
        out.write(tampered.data(), tampered.size());
    }

    // Confirm write length differs
    std::string tampered_read = read_file(tamper_path);
    if (tampered_read == original) {
        std::cerr << "[DIAG] Tamper write did not change file content!" << std::endl;
    } else {
        std::cerr << "[DIAG] Original size=" << original.size() << " Tampered size=" << tampered_read.size() << std::endl;
    }

    std::string tampered_root = compute_merkle_root_from_files(paths);

    // Restore
    {
        std::ofstream restore(tamper_path, std::ios::binary | std::ios::trunc);
        restore.write(original.data(), original.size());
    }

    REQUIRE(original_root != tampered_root);
}

#ifdef SODIUM_AVAILABLE
TEST_CASE(Signature_Verify_Success) {
    REQUIRE(verify_signature_ed25519(TEST_PUBKEY, TEST_SIG, TEST_MESSAGE));
}

TEST_CASE(Signature_Verify_InvalidSignature_Fails) {
    std::vector<unsigned char> bad_sig = TEST_SIG; bad_sig[0] ^= 0xFF; 
    REQUIRE(!verify_signature_ed25519(TEST_PUBKEY, bad_sig, TEST_MESSAGE));
}

TEST_CASE(Signature_Verify_WrongPubkey_Fails) {
    REQUIRE(!verify_signature_ed25519(WRONG_PUBKEY, TEST_SIG, TEST_MESSAGE));
}
#endif

int main(int argc, char** argv) { return run_all_tests(); }
