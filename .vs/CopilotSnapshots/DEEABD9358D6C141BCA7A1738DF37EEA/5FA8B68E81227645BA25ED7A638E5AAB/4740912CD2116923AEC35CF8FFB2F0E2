#ifndef REQUIRE
#define REQUIRE(x) do { if(!(x)){ std::cerr << "REQUIRE failed: " #x "\n"; std::exit(1);} } while(0)
#endif
#ifndef REQUIRE_FALSE
#define REQUIRE_FALSE(x) REQUIRE(!(x))
#endif

#include "../VerifyEvidenceLib.h"
#include "../../../deps/catch2/catch.hpp"
#include "ed25519_test_vectors.h"
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <iostream>
#include <random>
#include <cstdlib>

static std::string read_file(const std::string &p) {
    std::ifstream in(p, std::ios::binary);
    std::ostringstream ss; ss << in.rdbuf();
    return ss.str();
}

static std::string hash_string_hex(const std::string &data) {
    auto h = compute_sha256(data);
    std::ostringstream os; os << std::hex;
    for (auto b : h) os << (b >> 4 & 0xF) << (b & 0xF);
    return os.str();
}

TEST_CASE(Merkle_RightOrder_ComputesExpectedRoot) {
    std::vector<std::string> paths = {
        "../../test_data/evidence1.txt",
        "../../test_data/evidence2.txt",
        "../../test_data/evidence3.txt"
    };
    std::string root = compute_merkle_root_from_files(paths);
    std::string expected = compute_merkle_root_from_files(paths);
    REQUIRE(root == expected);
}

TEST_CASE(Merkle_TamperedFile_FailsMatch) {
    std::vector<std::string> paths = {
        "../../test_data/evidence1.txt",
        "../../test_data/evidence2.txt",
        "../../test_data/evidence3.txt"
    };
    std::string original_root = compute_merkle_root_from_files(paths);

    std::string tamper_path = "../../test_data/evidence2.txt";
    std::string original = read_file(tamper_path);
    std::string original_hash = hash_string_hex(original);

    std::string tampered(original.size(), '\0');
    tampered += "_TAMPER";
    {
        std::ofstream out(tamper_path, std::ios::binary | std::ios::trunc);
        out.write(tampered.data(), tampered.size());
        out.flush();
    }

    std::string tampered_read = read_file(tamper_path);
    std::string tampered_hash = hash_string_hex(tampered_read);

    REQUIRE(original_hash != tampered_hash);
    REQUIRE(original != tampered_read);

    std::string tampered_root = compute_merkle_root_from_files(paths);

    {
        std::ofstream restore(tamper_path, std::ios::binary | std::ios::trunc);
        restore.write(original.data(), original.size());
        restore.flush();
    }

    REQUIRE(original_root != tampered_root);
}

TEST_CASE(BatchMerkleProof_Verify_Succeeds) {
    std::vector<std::string> paths = {
        "../../test_data/evidence1.txt",
        "../../test_data/evidence2.txt",
        "../../test_data/evidence3.txt",
        "../../test_data/evidence1.txt"
    };
    std::vector<size_t> targets = {0,2};
    auto proof = build_batch_merkle_proof(paths, targets);
    REQUIRE(!proof.rootHex.empty());
    REQUIRE(proof.leaves.size() == targets.size());
    REQUIRE(verify_batch_merkle_proof(proof));
}

TEST_CASE(BatchMerkleProof_Tamper_Fails) {
    std::vector<std::string> paths = {
        "../../test_data/evidence1.txt",
        "../../test_data/evidence2.txt",
        "../../test_data/evidence3.txt",
        "../../test_data/evidence1.txt"
    };
    std::vector<size_t> targets = {1,3};
    auto proof = build_batch_merkle_proof(paths, targets);
    REQUIRE(verify_batch_merkle_proof(proof));

    REQUIRE(!proof.leaves.empty());
    auto originalLeafHash = proof.leaves[0].leafHashHex;
    std::string modified = originalLeafHash;
    modified[0] = (modified[0] == 'a') ? 'b' : 'a';
    proof.leaves[0].leafHashHex = modified;
    REQUIRE(!verify_batch_merkle_proof(proof));

    proof.leaves[0].leafHashHex = originalLeafHash;
    REQUIRE(verify_batch_merkle_proof(proof));
    if (!proof.leaves[0].siblingHex.empty()) {
        auto originalSibling = proof.leaves[0].siblingHex[0];
        std::string modSibling = originalSibling;
        modSibling[1] = (modSibling[1] == '0') ? 'f' : '0';
        proof.leaves[0].siblingHex[0] = modSibling;
        REQUIRE(!verify_batch_merkle_proof(proof));
        proof.leaves[0].siblingHex[0] = originalSibling;
        REQUIRE(verify_batch_merkle_proof(proof));
    }
}

#ifdef SODIUM_AVAILABLE
TEST_CASE(Signature_Verify_Success) { REQUIRE(verify_signature_ed25519(TEST_PUBKEY, TEST_SIG, TEST_MESSAGE)); }
TEST_CASE(Signature_Verify_InvalidSignature_Fails) { std::vector<unsigned char> bad_sig = TEST_SIG; bad_sig[0] ^= 0xFF; REQUIRE(!verify_signature_ed25519(TEST_PUBKEY, bad_sig, TEST_MESSAGE)); }
TEST_CASE(Signature_Verify_WrongPubkey_Fails) { REQUIRE(!verify_signature_ed25519(WRONG_PUBKEY, TEST_SIG, TEST_MESSAGE)); }
#endif

int main(int argc, char** argv) { return run_all_tests(); }
