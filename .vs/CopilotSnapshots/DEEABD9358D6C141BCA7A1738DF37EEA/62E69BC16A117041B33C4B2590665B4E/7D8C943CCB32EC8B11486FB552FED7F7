#include "VerifyEvidenceLib.h"
#include <fstream>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <algorithm>
#include <cctype>

#ifdef SODIUM_AVAILABLE
#include <sodium.h>
#endif

static std::string to_hex(const std::vector<unsigned char>& data) {
    std::ostringstream ss;
    ss << std::hex << std::setfill('0');
    for (unsigned char c : data) ss << std::setw(2) << (int)c;
    return ss.str();
}

#ifdef SODIUM_AVAILABLE
std::vector<unsigned char> compute_sha256(const std::string &data) {
    std::vector<unsigned char> out(32);
    crypto_hash_sha256(out.data(), reinterpret_cast<const unsigned char*>(data.data()), data.size());
    return out;
}

bool verify_signature_ed25519(const std::vector<unsigned char>& pubkey,
                              const std::vector<unsigned char>& sig,
                              const std::string& message) {
    if (sig.size() != crypto_sign_BYTES || pubkey.size() != crypto_sign_PUBLICKEYBYTES) return false;
    int rc = crypto_sign_verify_detached(sig.data(), reinterpret_cast<const unsigned char*>(message.data()), message.size(), pubkey.data());
    return rc == 0;
}
#else
std::vector<unsigned char> compute_sha256(const std::string &data) {
    uint32_t acc = 2166136261u;
    for (unsigned char c : data) acc = (acc ^ c) * 16777619u;
    std::vector<unsigned char> out(32, 0);
    for (size_t i = 0; i < out.size(); ++i) out[i] = static_cast<unsigned char>((acc >> (8*(i%4))) & 0xff);
    return out;
}

bool verify_signature_ed25519(const std::vector<unsigned char>&,
                              const std::vector<unsigned char>&,
                              const std::string&) { return false; }
#endif

static bool is_hex_string(const std::string &s) {
    if (s.empty() || (s.size() % 2) != 0) return false;
    for (char c : s) if (!std::isxdigit(static_cast<unsigned char>(c))) return false;
    return true;
}

std::vector<unsigned char> load_pubkey_from_file(const std::string &path, std::string &err) {
    std::vector<unsigned char> result;
    std::ifstream in(path, std::ios::binary);
    if (!in) {
        err = "Failed to open pubkey file: " + path;
        return result;
    }
    std::ostringstream ss;
    ss << in.rdbuf();
    std::string content = ss.str();

    auto l = content.find_first_not_of(" \n\r\t");
    auto r = content.find_last_not_of(" \n\r\t");
    if (l == std::string::npos) content = ""; else content = content.substr(l, r - l + 1);

    if (is_hex_string(content)) {
        result.reserve(content.size()/2);
        for (size_t i = 0; i < content.size(); i += 2) {
            std::string byte = content.substr(i, 2);
            unsigned char val = static_cast<unsigned char>(std::stoul(byte, nullptr, 16));
            result.push_back(val);
        }
    } else {
        result.assign(content.begin(), content.end());
    }
    return result;
}

std::string compute_merkle_root_from_files(const std::vector<std::string>& paths) {
    std::vector<std::vector<unsigned char>> hashes;
    for (const auto &p : paths) {
        std::ifstream in(p, std::ios::binary);
        if (!in) {
            // Use empty content hash
            hashes.push_back(compute_sha256(std::string()));
            continue;
        }
        std::ostringstream ss;
        ss << in.rdbuf();
        auto h = compute_sha256(ss.str());
        hashes.push_back(h);
    }

    if (hashes.empty()) {
        auto h = compute_sha256(std::string());
        return to_hex(h);
    }

    while (hashes.size() > 1) {
        std::vector<std::vector<unsigned char>> next;
        for (size_t i = 0; i < hashes.size(); i += 2) {
            std::vector<unsigned char> left = hashes[i];
            std::vector<unsigned char> right = (i + 1 < hashes.size()) ? hashes[i+1] : hashes[i];
            std::string concat;
            concat.reserve(left.size() + right.size());
            concat.append(reinterpret_cast<const char*>(left.data()), left.size());
            concat.append(reinterpret_cast<const char*>(right.data()), right.size());
            next.push_back(compute_sha256(concat));
        }
        hashes.swap(next);
    }
    return to_hex(hashes[0]);
}
