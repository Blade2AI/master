[CmdletBinding()]param(
  [string]$VerifierExe = "src/verifier/build/Debug/Verify-Evidence.exe",
  [string]$PolicyManifest = "constitution/policy_manifest.yml",
  [string]$PolicySignature = "constitution/policy_manifest.sig",
  [string]$PubkeyFile = "config/secure_keys.yaml",
  [string]$OutputDir = "logs/compliance",
  [string]$Standards = "EU_Machinery_2023_1230,ISO_TS_15066,IEC_62443,ISO_12100,IEC_61508,GDPR,NIS2",
  [string]$AdditionalEvidence = "", # comma-separated list of extra evidence file paths
  [string]$StoredMerkleFile = "logs/tamper/stored_merkle_root.txt", # optional existing root
  [string]$SchemaPath = "docs/evidence_schema.json", # JSON schema for artifacts validation
  [switch]$Strict,
  [switch]$Verbose
)

function Write-Info($m){ Write-Host "[Harness] $m" -ForegroundColor Cyan }
function Write-Warn($m){ Write-Host "[Harness] $m" -ForegroundColor Yellow }
function Write-Err($m){ Write-Host "[Harness] $m" -ForegroundColor Red }

# --- Ensure output directory ---
if(-not (Test-Path $OutputDir)){ New-Item -ItemType Directory -Force -Path $OutputDir | Out-Null }

# --- Shared crypto instance (performance) ---
if(-not $Global:HarnessSha256){ $Global:HarnessSha256 = [System.Security.Cryptography.SHA256]::Create() }

# --- Helpers ---
function Get-FileSha256($path){
  $bytes = [System.IO.File]::ReadAllBytes($path)
  $hash = $Global:HarnessSha256.ComputeHash($bytes)
  -join ($hash | ForEach-Object { $_.ToString('x2') })
}
function Compute-MerkleRoot([string[]]$paths){
  $hashes = @()
  foreach($p in $paths){
    if(Test-Path $p){ $hashes += Get-FileSha256 $p } else { $hashes += ('0'*64) }
  }
  if($hashes.Count -eq 0){ return '' }
  while($hashes.Count -gt 1){
    $next = @()
    for($i=0;$i -lt $hashes.Count;$i+=2){
      $left = $hashes[$i]
      $right = if($i+1 -lt $hashes.Count){ $hashes[$i+1] } else { $left }
      $concatBytes = [System.Text.Encoding]::UTF8.GetBytes($left + $right)
      $h = $Global:HarnessSha256.ComputeHash($concatBytes)
      $next += (-join ($h | ForEach-Object { $_.ToString('x2') }))
    }
    $hashes = $next
  }
  return $hashes[0]
}
function Get-PubkeyThumbprint($pubPath){
  if(-not (Test-Path $pubPath)){ return $null }
  $content = Get-Content $pubPath -Raw
  # naive YAML base64 extraction for key named policy_pubkey
  $b64 = ($content -split "\r?\n" | Where-Object { $_ -match '^\s*policy_pubkey\s*:' } | ForEach-Object { ($_ -split ':',2)[1].Trim() }) | Select-Object -First 1
  if(-not $b64){ return $null }
  try {
    $raw = [System.Convert]::FromBase64String($b64)
    $h = $Global:HarnessSha256.ComputeHash($raw)
    $hex = -join ($h | ForEach-Object { $_.ToString('x2') })
    return $hex.Substring(0,12)
  } catch { return $null }
}

# --- Compliance mapping seed ---
function Get-ComplianceMapping {
  return @{
    "IEC_62443" = @{ "Control_03-01"="Authentication & Authorization"; "Control_04-02"="Audit Trail Integrity" };
    "NIST_CSF" = @{ "ID.AM-01"="Asset Inventory"; "PR.DS-01"="Data Protection" };
    "RWA_Assurance" = @{ "RWA_01"="Policy Origin"; "RWA_02"="Immutability Proof" }
  }
}

# Allow unit tests to dot-source without executing main logic
if($env:HARNESS_NO_EXECUTION){ return }

# --- File existence validation ---
$required = @($VerifierExe,$PolicyManifest,$PolicySignature)
$missing = @()
foreach($p in $required){ if(-not (Test-Path $p)){ $missing += $p } }
if($missing.Count -gt 0){
  Write-Err "Missing required files: $($missing -join ', ')"
  $summary = @{ VerificationStatus='FAILED'; Reason='MissingRequiredFiles'; Missing=$missing; Timestamp=(Get-Date).ToString('o') }
  $failPath = Join-Path $OutputDir "verification_missing_files.json"
  $summary | ConvertTo-Json -Depth 6 | Out-File $failPath -Encoding UTF8
  if($Strict){ exit 2 } else { Write-Warn "Continuing in non-strict mode with Failure status" }
}

# --- Execute verifier (capture stdout/stderr) ---
$engineResult = @{ ExitCode=-1; VerificationStatus='FAILED'; RawOutput=''; RawError='' }
if($missing.Count -eq 0){
  Write-Info "Running verifier: $VerifierExe"
  $cmdArgs = @($PolicyManifest,$PolicySignature)
  if(Test-Path $PubkeyFile){ $cmdArgs += $PubkeyFile }
  try {
    $outFile = New-TemporaryFile
    $errFile = New-TemporaryFile
    Start-Process -FilePath $VerifierExe -ArgumentList $cmdArgs -RedirectStandardOutput $outFile -RedirectStandardError $errFile -NoNewWindow -Wait
    $engineResult.ExitCode = $LASTEXITCODE
    $engineResult.RawOutput = (Get-Content $outFile -Raw)
    $engineResult.RawError = (Get-Content $errFile -Raw)
    Remove-Item $outFile,$errFile -Force -ErrorAction SilentlyContinue
    $engineResult.VerificationStatus = if($engineResult.ExitCode -eq 0){ 'PASSED' } else { 'FAILED' }
  } catch {
    $engineResult.RawError = "Verifier invocation exception: $_"
    $engineResult.VerificationStatus = 'FAILED'
  }
} else { $engineResult.RawOutput = 'Verifier skipped.' }

# --- Evidence artifact hashing list ---
$artifactPaths = @($PolicyManifest,$PolicySignature)
if(Test-Path $PubkeyFile){ $artifactPaths += $PubkeyFile }
if($AdditionalEvidence){ $artifactPaths += ($AdditionalEvidence -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ }) }
$artifactPaths = $artifactPaths | Where-Object { $_ -and (Test-Path $_) }
$artifacts = @()
foreach($a in $artifactPaths){
  $hash = Get-FileSha256 $a
  $fi = Get-Item $a
  $sigExtract = $null
  if($a -eq $PolicySignature){
    try { $sigRaw = Get-Content $a -Raw; $sigExtract = $sigRaw.Substring(0,[Math]::Min(120,$sigRaw.Length)) } catch {}
  }
  $artifacts += [PSCustomObject]@{
    path = $a
    sha256 = $hash
    size_bytes = $fi.Length
    modified_utc = $fi.LastWriteTimeUtc.ToString('o')
    signature_excerpt = $sigExtract
  }
}

# --- Merkle recompute ---
$recomputedRoot = if($artifacts.Count -gt 0){ Compute-MerkleRoot ($artifacts | ForEach-Object { $_.path }) } else { '' }
$storedRoot = if(Test-Path $StoredMerkleFile){ (Get-Content $StoredMerkleFile -Raw).Trim() } else { '' }
$rootMatch = if($storedRoot -and $recomputedRoot){ $storedRoot -eq $recomputedRoot } elseif(-not $storedRoot -and -not $recomputedRoot){ $true } else { $false }
$merkleStatus = if($engineResult.VerificationStatus -eq 'PASSED' -and $rootMatch){ 'PASSED' } elseif($engineResult.VerificationStatus -eq 'PASSED' -and -not $rootMatch){ 'PARTIAL' } elseif($engineResult.VerificationStatus -eq 'FAILED' -and $rootMatch){ 'PARTIAL' } else { 'FAILED' }

# --- Regression detection ---
$regressionDetected = $false
if($storedRoot -and -not $rootMatch){
  if($engineResult.VerificationStatus -ne 'PASSED' -or $merkleStatus -ne 'PASSED'){
    $regressionDetected = $true
    Write-Warn "MERKLE REGRESSION DETECTED: stored root does not match recomputed root and current verification not fully passed"
  }
}

# --- Overall status ---
$overallStatus = 'FAILED'
if($engineResult.VerificationStatus -eq 'PASSED' -and $merkleStatus -eq 'PASSED'){ $overallStatus='PASSED' }
elseif($engineResult.VerificationStatus -eq 'PASSED' -and $merkleStatus -ne 'PASSED'){ $overallStatus='PARTIAL' }
elseif($engineResult.VerificationStatus -ne 'PASSED' -and $merkleStatus -eq 'PASSED'){ $overallStatus='PARTIAL' }

# --- Standards rollup ---
$standardList = $Standards -split ',' | Where-Object { $_ }
$complianceMap = @{}
foreach($std in $standardList){
  $stdStatus = if($overallStatus -eq 'FAILED'){ 'FAILED' } elseif($overallStatus -eq 'PARTIAL'){ 'PARTIAL' } else { 'PASSED' }
  if($stdStatus -eq 'PASSED' -and $std -in @('IEC_62443','NIS2')){ $stdStatus = 'PARTIAL' }
  $complianceMap[$std] = $stdStatus
}

# --- Control mapping ---
$controlSource = Get-ComplianceMapping
$detailedControls = @{}
foreach($k in $controlSource.Keys){
  $detailedControls[$k] = @{}
  foreach($ctrl in $controlSource[$k].Keys){
    $ctrlStatus = if($overallStatus -eq 'PASSED'){ 'PASSED' } elseif($overallStatus -eq 'PARTIAL'){ 'PARTIAL' } else { 'FAILED' }
    $detailedControls[$k][$ctrl] = $ctrlStatus
  }
}

# --- Pubkey thumbprint ---
$pubThumb = Get-PubkeyThumbprint $PubkeyFile

# --- Schema validation (deep) ---
$schemaStatus='SKIPPED'; $schemaErrors=@(); $artifactSchemaErrors=@()
if(Test-Path $SchemaPath){
  try {
    $schema=Get-Content $SchemaPath -Raw | ConvertFrom-Json
    $schemaArtifacts=@(); foreach($a in $artifacts){ $schemaArtifacts+=[PSCustomObject]@{ path=$a.path; sha256=$a.sha256; signature=$a.signature_excerpt; merkle_root_before=$storedRoot; merkle_root_after=$recomputedRoot } }
    $schemaCandidate=[PSCustomObject]@{ build_id="build-$([int](Get-Date -UFormat %s))"; timestamp=(Get-Date).ToString('o'); status= ($overallStatus.ToLower()); artifacts=$schemaArtifacts }
    foreach($r in $schema.required){ if(-not ($schemaCandidate.PSObject.Properties.Name -contains $r)){ $schemaErrors+="Missing required top-level field '$r'" } }
    # Per-artifact validation
    if($schema.properties.artifacts.items.required){
      for($i=0;$i -lt $schemaCandidate.artifacts.Count; $i++){
        $art=$schemaCandidate.artifacts[$i]
        foreach($req in $schema.properties.artifacts.items.required){ if(-not ($art.PSObject.Properties.Name -contains $req)){ $artifactSchemaErrors+="Artifact[$i] missing field '$req'" } }
      }
    }
    if($schemaErrors.Count -eq 0 -and $artifactSchemaErrors.Count -eq 0){ $schemaStatus='PASSED' } else { $schemaStatus='FAILED' }
  } catch { $schemaStatus='FAILED'; $schemaErrors+="Exception parsing schema: $_" }
}

# --- Harness integrity hash (script content) ---
$harnessPath = $PSCommandPath
$harnessSha256 = if(Test-Path $harnessPath){ Get-FileSha256 $harnessPath } else { '' }

# --- Report object ---
$report=[PSCustomObject]@{
  VerificationID="Audit-$([int](Get-Date -UFormat %s))";
  Timestamp=(Get-Date).ToString('o');
  PolicyManifestID=(Split-Path $PolicyManifest -Leaf);
  VerificationStatus=$overallStatus;
  Summary=[PSCustomObject]@{
    EngineExitCode=$engineResult.ExitCode;
    SignatureAuthStatus=$engineResult.VerificationStatus;
    MerkleChainStatus=$merkleStatus;
    MerkleRootStored=$storedRoot;
    MerkleRootRecomputed=$recomputedRoot;
    MerkleRootMatch=$rootMatch;
    EvidenceFileCount=$artifacts.Count;
    RawEngineOutput=$engineResult.RawOutput;
    RawEngineError=$engineResult.RawError;
    PubkeyThumbprint=$pubThumb;
    SchemaValidationStatus=$schemaStatus;
    SchemaErrors=$schemaErrors;
    ArtifactSchemaErrors=$artifactSchemaErrors;
    MerkleRootPersisted=$false;
    MerkleRootSignature='UNSIGNED';
    RegressionDetected=$regressionDetected;
    HarnessScriptSha256=$harnessSha256;
    HarnessExitCode=-1
  };
  StandardsRollup=$complianceMap;
  ComplianceMapping=$detailedControls;
  Artifacts=$artifacts
}

# --- Persist recomputed root ---
if($overallStatus -eq 'PASSED'){
  $persistNeeded = (-not $storedRoot) -or ($storedRoot -ne $recomputedRoot)
  if($persistNeeded -and $recomputedRoot){
    try {
      $storeDir = Split-Path $StoredMerkleFile -Parent
      if(-not (Test-Path $storeDir)){ New-Item -ItemType Directory -Force -Path $storeDir | Out-Null }
      $recomputedRoot | Out-File $StoredMerkleFile -Encoding ASCII -Force
      $historyFile = Join-Path $storeDir "stored_merkle_history.jsonl"
      $historyEntry = @{ timestamp=(Get-Date).ToString('o'); merkle_root=$recomputedRoot; verification_id=$report.VerificationID } | ConvertTo-Json -Depth 4
      Add-Content -Path $historyFile -Value $historyEntry
      $report.Summary.MerkleRootPersisted = $true
      Write-Info "Persisted new Merkle root to $StoredMerkleFile"
      if(Get-Command -Name New-MessageSignature -ErrorAction SilentlyContinue){
        try {
          $sigObj = New-MessageSignature -Data $recomputedRoot -NodeID 'VERIFICATION_HARNESS' -Purpose 'MERKLE_ROOT_ACCEPTED'
          if($sigObj){
            $sigFile = Join-Path $storeDir 'stored_merkle_root.sig.json'
            $sigObj | ConvertTo-Json -Depth 6 | Out-File $sigFile -Encoding UTF8
            $report.Summary.MerkleRootSignature = $sigObj.value.Substring(0,[Math]::Min(32,$sigObj.value.Length)) + '...'
            Write-Info "Merkle root signed (excerpt: $($report.Summary.MerkleRootSignature))"
          }
        } catch { Write-Warn "Signing merkle root failed: $_" }
      } else { Write-Warn "Signing command New-MessageSignature not found; merkle root left unsigned" }
    } catch { Write-Warn "Failed to persist Merkle root: $_" }
  }
}

# --- Regression artifact ---
if($regressionDetected){
  try {
    $regFile = Join-Path $OutputDir 'merkle_regression_event.json'
    @{ timestamp=(Get-Date).ToString('o'); stored_root=$storedRoot; recomputed_root=$recomputedRoot; verification_id=$report.VerificationID; status=$overallStatus; message='MERKLE REGRESSION DETECTED' } | ConvertTo-Json -Depth 6 | Out-File $regFile -Encoding UTF8
    Write-Warn "Regression event written: $regFile"
  } catch { Write-Warn "Failed to write regression event: $_" }
}

# --- Write artifacts ---
$reportPath=Join-Path $OutputDir "verification_summary.json"; $report | ConvertTo-Json -Depth 14 | Out-File $reportPath -Encoding UTF8
$artifactsPath=Join-Path $OutputDir "verification_artifacts.json"; $artifacts | ConvertTo-Json -Depth 6 | Out-File $artifactsPath -Encoding UTF8
Write-Info "Summary written: $reportPath"; if($Verbose){ Write-Host ($report | ConvertTo-Json -Depth 14) }

# --- Exit code ---
$finalExit = if($missing.Count -gt 0){ 2 } elseif($overallStatus -eq 'PASSED'){ 0 } elseif($overallStatus -eq 'PARTIAL'){ 1 } else { 3 }
$report.Summary.HarnessExitCode = $finalExit
Set-Content -Path $reportPath -Value ($report | ConvertTo-Json -Depth 14) -Encoding UTF8

# --- Metrics history append ---
try {
  $metricsDir = "logs/metrics"
  if(-not (Test-Path $metricsDir)){ New-Item -ItemType Directory -Force -Path $metricsDir | Out-Null }
  $metricsFile = Join-Path $metricsDir 'audit_history.json'
  $entry = [PSCustomObject]@{
    timestamp = (Get-Date).ToString('o')
    verification_status = $overallStatus
    exit_code = $finalExit
    verification_id = $report.VerificationID
    merkle_root_match = $report.Summary.MerkleRootMatch
    regression_detected = $report.Summary.RegressionDetected
    schema_status = $report.Summary.SchemaValidationStatus
    evidence_file_count = $report.Summary.EvidenceFileCount
  }
  $history = @()
  if(Test-Path $metricsFile){
    try { $rawHist = Get-Content $metricsFile -Raw; if($rawHist){ $parsed = $rawHist | ConvertFrom-Json; if($parsed){ $history = $parsed } } } catch { $history = @() }
    if(-not ($history -is [System.Collections.IEnumerable])){ $history = @() }
  }
  $history += $entry
  $history | ConvertTo-Json -Depth 6 | Out-File $metricsFile -Encoding UTF8
  Write-Info "Metrics history updated: $metricsFile"

  # --- Rotation & aggregation (config-driven) ---
  $configPath = 'config/metrics_config.yaml'
  $cfg = $null
  if(Test-Path $configPath){
    try {
      $rawCfg = Get-Content $configPath -Raw
      # Minimal YAML parsing (key: value lines)
      $cfg = @{}
      $rawCfg -split "\r?\n" | Where-Object { $_ -match ':' } | ForEach-Object {
        $k,$v = ($_ -split ':',2); $cfg[$k.Trim()] = $v.Trim()
      }
    } catch { Write-Warn "Failed to parse metrics config: $_" }
  }
  if(-not $cfg){ $cfg = @{ max_file_size_mb='2'; rotate_interval='daily'; raw_retention_days='30'; keep_last_n='5000'; aggregation_interval='daily'; max_total_size_mb='20' } }

  function Get-IntOrDefault($map,$key,$default){ if($map.ContainsKey($key) -and [int]::TryParse($map[$key],[ref]([int]$null))){ return [int]$map[$key] } else { return $default } }
  $maxFileSizeMb = Get-IntOrDefault $cfg 'max_file_size_mb' 2
  $rawRetentionDays = Get-IntOrDefault $cfg 'raw_retention_days' 30
  $keepLastN = Get-IntOrDefault $cfg 'keep_last_n' 5000
  $maxTotalSizeMb = Get-IntOrDefault $cfg 'max_total_size_mb' 20
  $rotateInterval = $cfg['rotate_interval']
  $aggInterval = $cfg['aggregation_interval']

  # Rotation triggers
  $rotateReason = $null
  $fileSizeMb = 0
  if(Test-Path $metricsFile){ $fileSizeMb = ([Math]::Round((Get-Item $metricsFile).Length / 1MB,2)) }
  if($fileSizeMb -gt $maxFileSizeMb){ $rotateReason = "size>$maxFileSizeMb MB ($fileSizeMb MB)" }
  elseif($rotateInterval -eq 'daily'){
    # If earliest record not today
    try {
      $earliest = ($history | Sort-Object timestamp | Select-Object -First 1).timestamp
      if($earliest){ $earliestDate = [DateTime]::Parse($earliest).Date; if($earliestDate -lt (Get-Date).Date){ $rotateReason = 'daily interval' } }
    } catch {}
  }
  elseif($rotateInterval -eq 'hourly'){
    try {
      $earliest = ($history | Sort-Object timestamp | Select-Object -First 1).timestamp
      if($earliest){ $earliestHour = [DateTime]::Parse($earliest).Hour; if($earliestHour -ne (Get-Date).Hour){ $rotateReason = 'hourly interval' } }
    } catch {}
  }

  if($rotateReason){
    try {
      $stamp = (Get-Date).ToString('yyyy-MM-dd_HHmmss')
      $rotatedName = "audit_history_$stamp.json"
      $rotatedPath = Join-Path $metricsDir $rotatedName
      Copy-Item $metricsFile $rotatedPath -Force
      Write-Info "Rotated metrics history ($rotateReason) -> $rotatedName"
      # Reset current file to last entry only to start fresh window
      $entry | ConvertTo-Json -Depth 6 | Out-File $metricsFile -Encoding UTF8
    } catch { Write-Warn "Rotation failed: $_" }
  }

  # Retention: prune rotated files older than raw_retention_days or enforce max total size
  try {
    $rotatedFiles = Get-ChildItem $metricsDir -Filter 'audit_history_*.json' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime
    $cutoff = (Get-Date).AddDays(-$rawRetentionDays)
    foreach($f in $rotatedFiles){ if($f.LastWriteTime -lt $cutoff){ Remove-Item $f.FullName -Force; Write-Info "Pruned old metrics file: $($f.Name)" } }
    # Enforce max total size
    $rotatedFiles = Get-ChildItem $metricsDir -Filter 'audit_history_*.json' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime
    $totalSizeMb = ([Math]::Round(($rotatedFiles | Measure-Object -Property Length -Sum).Sum / 1MB,2))
    while($totalSizeMb -gt $maxTotalSizeMb -and $rotatedFiles.Count -gt 0){
      $old = $rotatedFiles[0]; Remove-Item $old.FullName -Force; Write-Info "Pruned for total size cap: $($old.Name)"; $rotatedFiles = Get-ChildItem $metricsDir -Filter 'audit_history_*.json' | Sort-Object LastWriteTime; $totalSizeMb = ([Math]::Round(($rotatedFiles | Measure-Object -Property Length -Sum).Sum / 1MB,2))
    }
  } catch { Write-Warn "Retention pass failed: $_" }

  # Aggregation
  try {
    $aggFile = Join-Path $metricsDir 'audit_summary.json'
    $allCurrent = @()
    if(Test-Path $metricsFile){ try { $allCurrent = (Get-Content $metricsFile -Raw | ConvertFrom-Json); if(-not ($allCurrent -is [System.Collections.IEnumerable])){ $allCurrent=@($allCurrent) } } catch { $allCurrent=@() } }
    # Include rotated files for window if daily or weekly
    $rotatedForAgg = @()
    if($aggInterval -in @('daily','weekly')){
      $rotatedForAgg = Get-ChildItem $metricsDir -Filter 'audit_history_*.json' -ErrorAction SilentlyContinue | ForEach-Object { try { (Get-Content $_.FullName -Raw | ConvertFrom-Json) } catch { $null } } | Where-Object { $_ }
    }
    $records = @($allCurrent + $rotatedForAgg) | Where-Object { $_.timestamp }
    if($records.Count -gt 0){
      $now = Get-Date
      $windowStart = if($aggInterval -eq 'daily'){ $now.Date } elseif($aggInterval -eq 'weekly'){ $now.Date.AddDays(-($now.DayOfWeek.value__)) } else { $now.AddHours(-1) }
      $windowRecords = $records | Where-Object { [DateTime]::Parse($_.timestamp) -ge $windowStart }
      if($windowRecords.Count -gt 0){
        $successCount = ($windowRecords | Where-Object { $_.verification_status -eq 'PASSED' }).Count
        $failureCount = ($windowRecords | Where-Object { $_.verification_status -eq 'FAILED' }).Count
        $partialCount = ($windowRecords | Where-Object { $_.verification_status -eq 'PARTIAL' }).Count
        $total = $windowRecords.Count
        $successRate = if($total -gt 0){ [Math]::Round($successCount / $total,4) } else { 0 }
        $summary = [PSCustomObject]@{
          window_start = $windowStart.ToString('o')
          window_end = $now.ToString('o')
          total_runs = $total
          success_count = $successCount
          failure_count = $failureCount
          partial_count = $partialCount
          success_rate = $successRate
        }
        $existing = @()
        if(Test-Path $aggFile){ try { $rawAgg = Get-Content $aggFile -Raw; if($rawAgg){ $existing = $rawAgg | ConvertFrom-Json } } catch { $existing=@() } }
        if(-not ($existing -is [System.Collections.IEnumerable])){ $existing=@() }
        # Append or update same window_start if exists
        $existing = $existing | Where-Object { $_.window_start -ne $summary.window_start }
        $existing += $summary
        $existing | ConvertTo-Json -Depth 4 | Out-File $aggFile -Encoding UTF8
        Write-Info "Aggregated metrics updated: $aggFile (success_rate=$successRate)"
      }
    }
  } catch { Write-Warn "Aggregation failed: $_" }

} catch { Write-Warn "Failed to append metrics history: $_" }

exit $finalExit
