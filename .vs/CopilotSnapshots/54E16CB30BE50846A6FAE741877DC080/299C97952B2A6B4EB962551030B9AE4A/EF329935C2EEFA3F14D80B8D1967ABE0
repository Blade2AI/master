[CmdletBinding()]param(
  [string]$VerifierExe = "src/verifier/build/Debug/Verify-Evidence.exe",
  [string]$PolicyManifest = "constitution/policy_manifest.yml",
  [string]$PolicySignature = "constitution/policy_manifest.sig",
  [string]$PubkeyFile = "config/secure_keys.yaml",
  [string]$OutputDir = "logs/compliance",
  [string]$Standards = "EU_Machinery_2023_1230,ISO_TS_15066,IEC_62443,ISO_12100,IEC_61508,GDPR,NIS2",
  [string]$AdditionalEvidence = "", # comma-separated list of extra evidence file paths
  [switch]$Strict,
  [switch]$Verbose
)

function Write-Info($m){ Write-Host "[Harness] $m" -ForegroundColor Cyan }
function Write-Warn($m){ Write-Host "[Harness] $m" -ForegroundColor Yellow }
function Write-Err($m){ Write-Host "[Harness] $m" -ForegroundColor Red }

# --- Ensure output directory ---
if(-not (Test-Path $OutputDir)){ New-Item -ItemType Directory -Force -Path $OutputDir | Out-Null }

# --- Helpers ---
function Get-FileSha256($path){
  $bytes = [System.IO.File]::ReadAllBytes($path)
  $sha = [System.Security.Cryptography.SHA256]::Create()
  $hash = $sha.ComputeHash($bytes)
  -join ($hash | ForEach-Object { $_.ToString('x2') })
}
function Compute-MerkleRoot([string[]]$paths){
  $hashes = @()
  foreach($p in $paths){
    if(Test-Path $p){ $hashes += Get-FileSha256 $p } else { $hashes += ('0'*64) }
  }
  if($hashes.Count -eq 0){ return '' }
  while($hashes.Count -gt 1){
    $next = @()
    for($i=0;$i -lt $hashes.Count;$i+=2){
      $left = $hashes[$i]
      $right = if($i+1 -lt $hashes.Count){ $hashes[$i+1] } else { $left }
      $concatBytes = [System.Text.Encoding]::UTF8.GetBytes($left + $right)
      $sha = [System.Security.Cryptography.SHA256]::Create()
      $h = $sha.ComputeHash($concatBytes)
      $next += (-join ($h | ForEach-Object { $_.ToString('x2') }))
    }
    $hashes = $next
  }
  return $hashes[0]
}
function Get-PubkeyThumbprint($pubPath){
  if(-not (Test-Path $pubPath)){ return $null }
  $content = Get-Content $pubPath -Raw
  # naive YAML base64 extraction for key named policy_pubkey
  $b64 = ($content -split "\r?\n" | Where-Object { $_ -match '^\s*policy_pubkey\s*:' } | ForEach-Object { ($_ -split ':',2)[1].Trim() }) | Select-Object -First 1
  if(-not $b64){ return $null }
  try {
    $raw = [System.Convert]::FromBase64String($b64)
    $sha = [System.Security.Cryptography.SHA256]::Create()
    $h = $sha.ComputeHash($raw)
    $hex = -join ($h | ForEach-Object { $_.ToString('x2') })
    return $hex.Substring(0,12)
  } catch { return $null }
}

# --- Compliance mapping seed ---
function Get-ComplianceMapping {
  return @{
    "IEC_62443" = @{ "Control_03-01"="Authentication & Authorization"; "Control_04-02"="Audit Trail Integrity" };
    "NIST_CSF" = @{ "ID.AM-01"="Asset Inventory"; "PR.DS-01"="Data Protection" };
    "RWA_Assurance" = @{ "RWA_01"="Policy Origin"; "RWA_02"="Immutability Proof" }
  }
}

# --- File existence validation ---
$required = @($VerifierExe,$PolicyManifest,$PolicySignature)
$missing = @()
foreach($p in $required){ if(-not (Test-Path $p)){ $missing += $p } }
if($missing.Count -gt 0){
  Write-Err "Missing required files: $($missing -join ', ')"
  $summary = @{ VerificationStatus='FAILED'; Reason='MissingRequiredFiles'; Missing=$missing; Timestamp=(Get-Date).ToString('o') }
  $failPath = Join-Path $OutputDir "verification_missing_files.json"
  $summary | ConvertTo-Json -Depth 6 | Out-File $failPath -Encoding UTF8
  if($Strict){ exit 2 } else { Write-Warn "Continuing in non-strict mode with Failure status" }
}

# --- Execute verifier ---
$engineResult = @{ ExitCode=-1; VerificationStatus='FAILED'; RawOutput=''; RawError='' }
if($missing.Count -eq 0){
  Write-Info "Running verifier: $VerifierExe"
  $cmdArgs = @($PolicyManifest,$PolicySignature)
  if(Test-Path $PubkeyFile){ $cmdArgs += $PubkeyFile }
  $rawOut = & $VerifierExe @cmdArgs *>&1
  $exit = $LASTEXITCODE
  $engineResult.ExitCode = $exit
  $engineResult.RawOutput = ($rawOut -join "`n")
  $engineResult.VerificationStatus = if($exit -eq 0){'PASSED'} else {'FAILED'}
} else { $engineResult.RawOutput = 'Verifier skipped.' }

# --- Evidence artifact hashing list ---
$artifactPaths = @($PolicyManifest,$PolicySignature)
if(Test-Path $PubkeyFile){ $artifactPaths += $PubkeyFile }
if($AdditionalEvidence){ $artifactPaths += ($AdditionalEvidence -split ',') }
$artifactPaths = $artifactPaths | Where-Object { $_ -and (Test-Path $_) }
$artifacts = @()
foreach($a in $artifactPaths){
  $hash = Get-FileSha256 $a
  $fi = Get-Item $a
  $sigExtract = $null
  if($a -eq $PolicySignature){
    try { $sigExtract = (Get-Content $a -Raw).Substring(0,[Math]::Min(120,(Get-Content $a -Raw).Length)) } catch {}
  }
  $artifacts += [PSCustomObject]@{
    path = $a
    sha256 = $hash
    size_bytes = $fi.Length
    modified_utc = $fi.LastWriteTimeUtc.ToString('o')
    signature_excerpt = $sigExtract
  }
}

# --- Merkle recompute ---
$merkleRoot = if($artifacts.Count -gt 0){ Compute-MerkleRoot ($artifacts | ForEach-Object { $_.path }) } else { '' }
$merkleStatus = if($engineResult.VerificationStatus -eq 'PASSED'){ 'PASSED' } elseif($artifacts.Count -eq 0){ 'UNKNOWN' } else { 'PARTIAL' }

# --- Partial failure mapping ---
$overallStatus = 'FAILED'
if($engineResult.VerificationStatus -eq 'PASSED' -and $merkleStatus -eq 'PASSED'){ $overallStatus='PASSED' }
elseif($engineResult.VerificationStatus -eq 'PASSED' -and $merkleStatus -ne 'PASSED'){ $overallStatus='PARTIAL' }
elseif($engineResult.VerificationStatus -ne 'PASSED' -and $merkleStatus -eq 'PASSED'){ $overallStatus='PARTIAL' }

# --- Standards rollup ---
$standardList = $Standards -split ',' | Where-Object { $_ }
$complianceMap = @{}
foreach($std in $standardList){
  $status = 'pass'
  if($std -in @('IEC_62443','NIS2')){ $status='warn' }
  if($overallStatus -eq 'FAILED'){ $status='fail' } elseif($overallStatus -eq 'PARTIAL' -and $status -eq 'pass'){ $status='warn' }
  $complianceMap[$std] = $status
}

# --- Control mapping ---
$controlSource = Get-ComplianceMapping
$detailedControls = @{}
foreach($k in $controlSource.Keys){
  $detailedControls[$k] = @{}
  foreach($ctrl in $controlSource[$k].Keys){
    $ctrlStatus = if($overallStatus -eq 'PASSED'){ 'PASSED' } elseif($overallStatus -eq 'PARTIAL'){ 'PARTIAL' } else { 'FAILED' }
    $detailedControls[$k][$ctrl] = $ctrlStatus
  }
}

# --- Pubkey thumbprint ---
$pubThumb = Get-PubkeyThumbprint $PubkeyFile

# --- Report object ---
$report = [PSCustomObject]@{
  VerificationID = "Audit-$([int](Get-Date -UFormat %s))"
  Timestamp = (Get-Date).ToString('o')
  PolicyManifestID = (Split-Path $PolicyManifest -Leaf)
  VerificationStatus = $overallStatus
  Summary = [PSCustomObject]@{
    EngineExitCode = $engineResult.ExitCode
    SignatureAuthStatus = $engineResult.VerificationStatus
    MerkleChainStatus = $merkleStatus
    MerkleRoot = $merkleRoot
    EvidenceFileCount = $artifacts.Count
    RawEngineOutput = $engineResult.RawOutput
    PubkeyThumbprint = $pubThumb
  }
  StandardsRollup = $complianceMap
  ComplianceMapping = $detailedControls
  Artifacts = $artifacts
}

$reportPath = Join-Path $OutputDir "verification_summary.json"
$report | ConvertTo-Json -Depth 12 | Out-File $reportPath -Encoding UTF8
Write-Info "Summary written: $reportPath"; if($Verbose){ Write-Host ($report | ConvertTo-Json -Depth 12) }

# Write separate artifacts file for audit trail
$artifactsPath = Join-Path $OutputDir "verification_artifacts.json"
$artifacts | ConvertTo-Json -Depth 6 | Out-File $artifactsPath -Encoding UTF8
if($Verbose){ Write-Info "Artifacts written: $artifactsPath" }

# Exit code semantics
if($missing.Count -gt 0){ exit 2 }
elseif($overallStatus -eq 'PASSED'){ exit 0 }
elseif($overallStatus -eq 'PARTIAL'){ exit 1 }
else{ exit 3 }
